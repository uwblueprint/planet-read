diff --git a/.circleci/config.yml b/.circleci/config.yml
index 160cd09..65cc727 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -1,24 +1,24 @@
-version: 2.1
-jobs:
-  build:
-    docker:
-      - image: cimg/base:2021.05
-    steps:
-      - checkout
-      - setup_remote_docker:
-          version: 19.03.13
-          docker_layer_caching: false
-      - run:
-          name: Create env file
-          command: |
-            touch .env
-      - run: 
-          name: Start container via docker-compose
-          command: |
-            set -x
-            docker-compose up -d
-workflows:
-  version: 2
-  build:
-    jobs:
+version: 2.1
+jobs:
+  build:
+    docker:
+      - image: cimg/base:2021.05
+    steps:
+      - checkout
+      - setup_remote_docker:
+          version: 19.03.13
+          docker_layer_caching: false
+      - run:
+          name: Create env file
+          command: |
+            touch .env
+      - run: 
+          name: Start container via docker-compose
+          command: |
+            set -x
+            docker-compose up -d
+workflows:
+  version: 2
+  build:
+    jobs:
       - build
\ No newline at end of file
diff --git a/.github/workflows/firebase-hosting-merge.yml b/.github/workflows/firebase-hosting-merge.yml
index 49038c3..51d9350 100644
--- a/.github/workflows/firebase-hosting-merge.yml
+++ b/.github/workflows/firebase-hosting-merge.yml
@@ -1,22 +1,23 @@
-# This file was auto-generated by the Firebase CLI
-# https://github.com/firebase/firebase-tools
-
-name: Deploy to Firebase Hosting on merge
-'on':
-  push:
-    branches:
-      - main
-jobs:
-  build_and_deploy:
-    runs-on: ubuntu-latest
-    steps:
-      - uses: actions/checkout@v2
-      - run: docker-compose up --build
-      - uses: FirebaseExtended/action-hosting-deploy@v0
-        with:
-          repoToken: '${{ secrets.GITHUB_TOKEN }}'
-          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_PLANET_READ_UWBP }}'
-          channelId: live
-          projectId: planet-read-uwbp
-# - name: Create .env file
-#   uses: SpicyPizza/create-envfile@v1.1
+# This file was auto-generated by the Firebase CLI
+# https://github.com/firebase/firebase-tools
+
+name: Deploy to Firebase Hosting on merge
+'on':
+  push:
+    branches:
+      - main
+jobs:
+  build_and_deploy:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      # - run: touch /home/runner/work/planet-read/planet-read/.env 
+      - run: docker-compose up --build
+      - uses: FirebaseExtended/action-hosting-deploy@v0
+        with:
+          repoToken: '${{ secrets.GITHUB_TOKEN }}'
+          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_PLANET_READ_UWBP }}'
+          channelId: live
+          projectId: planet-read-uwbp
+# - name: Create .env file
+#   uses: SpicyPizza/create-envfile@v1.1
diff --git a/.github/workflows/firebase-hosting-pull-request.yml b/.github/workflows/firebase-hosting-pull-request.yml
index ac7d494..d11bbcd 100644
--- a/.github/workflows/firebase-hosting-pull-request.yml
+++ b/.github/workflows/firebase-hosting-pull-request.yml
@@ -1,19 +1,21 @@
-# This file was auto-generated by the Firebase CLI
-# https://github.com/firebase/firebase-tools
-
-name: Deploy to Firebase Hosting on PR
-'on': pull_request
-jobs:
-  build_and_preview:
-    if: '${{ github.event.pull_request.head.repo.full_name == github.repository }}'
-    runs-on: ubuntu-latest
-    steps:
-      - uses: actions/checkout@v2
-      - run: docker-compose up --build
-      - uses: FirebaseExtended/action-hosting-deploy@v0
-        with:
-          repoToken: '${{ secrets.GITHUB_TOKEN }}'
-          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_PLANET_READ_UWBP }}'
-          projectId: planet-read-uwbp
-# - name: Create .env file
-#   uses: SpicyPizza/create-envfile@v1.1
+# This file was auto-generated by the Firebase CLI
+# https://github.com/firebase/firebase-tools
+
+name: Deploy to Firebase Hosting on PR
+'on': pull_request
+jobs:
+  build_and_preview:
+    if: '${{ github.event.pull_request.head.repo.full_name == github.repository }}'
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      # - run: touch /home/runner/work/planet-read/planet-read/.env 
+      - run: docker-compose up --build
+      - uses: FirebaseExtended/action-hosting-deploy@v0
+        with:
+          repoToken: '${{ secrets.GITHUB_TOKEN }}'
+          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_PLANET_READ_UWBP }}'
+          projectId: planet-read-uwbp
+
+# - name: Create .env file
+#   uses: SpicyPizza/create-envfile@v1.1
diff --git a/README.md b/README.md
index 05e3c50..981bf91 100644
--- a/README.md
+++ b/README.md
@@ -1,46 +1,46 @@
-# üåè Planet Read
-
-üêò Postgres + üêç Flask story translation platform.  
-
-Made with [starter-code-v2](https://github.com/uwblueprint/starter-code-v2), brought to you by the @uwblueprint/internal-tools team!
-
-# Getting Started
-## Vault
-Get [started with vault](https://www.notion.so/uwblueprintexecs/Secret-Management-2d5b59ef0987415e93ec951ce05bf03e). To grab the project's secrets, run
-```
-vault kv get -format=json kv/planet-read | python update_secret_files.py
-```
-You should have three new files in your repo after this:
-- `.env`
-- `backend/.env`
-- `backend/python/firebaseServiceAccount.json`
-## Prereqs
-Verify that you have docker and npx installed:
-```
-docker info
-docker-compose --version
-npx -v
-```
-# Build and Run
-Note: if you have already built the project before, run this first: 
-```
-docker-compose down --volumes
-```
-
-And run the project:
-```
-docker-compose up --build
-```
-Don't forget to seed your database with a firebase user: 
-```
-docker ps
-docker exec -it <db-container-id> /bin/bash
-psql -U postgres -d planet-read
-INSERT INTO users (first_name, last_name, auth_id, role) VALUES ('First', 'Last', 'insert-firebase-uid', 'Admin');
-```
-
-If there are no tables in the DB, go into `/backend/python/app/models/__init__.py` and change the `erase_db_and_sync = False` to True, allow the hot reload to build, and change it back to `False`. Try to seed the database with a user again.
-
-Follow the [getting started](https://uwblueprint.github.io/starter-code-v2/docs/getting-started) for more details, especially if you desire to use your own firebase and gcp projects.
-
+# üåè Planet Read
+
+üêò Postgres + üêç Flask story translation platform.  
+
+Made with [starter-code-v2](https://github.com/uwblueprint/starter-code-v2), brought to you by the @uwblueprint/internal-tools team!
+
+# Getting Started
+## Vault
+Get [started with vault](https://www.notion.so/uwblueprintexecs/Secret-Management-2d5b59ef0987415e93ec951ce05bf03e). To grab the project's secrets, run
+```
+vault kv get -format=json kv/planet-read | python update_secret_files.py
+```
+You should have three new files in your repo after this:
+- `.env`
+- `backend/.env`
+- `backend/python/firebaseServiceAccount.json`
+## Prereqs
+Verify that you have docker and npx installed:
+```
+docker info
+docker-compose --version
+npx -v
+```
+# Build and Run
+Note: if you have already built the project before, run this first: 
+```
+docker-compose down --volumes
+```
+
+And run the project:
+```
+docker-compose up --build
+```
+Don't forget to seed your database with a firebase user: 
+```
+docker ps
+docker exec -it <db-container-id> /bin/bash
+psql -U postgres -d planet-read
+INSERT INTO users (first_name, last_name, auth_id, role) VALUES ('First', 'Last', 'insert-firebase-uid', 'Admin');
+```
+
+If there are no tables in the DB, go into `/backend/python/app/models/__init__.py` and change the `erase_db_and_sync = False` to True, allow the hot reload to build, and change it back to `False`. Try to seed the database with a user again.
+
+Follow the [getting started](https://uwblueprint.github.io/starter-code-v2/docs/getting-started) for more details, especially if you desire to use your own firebase and gcp projects.
+
 Happy hacking! üíªüöÄ
\ No newline at end of file
diff --git a/backend/python/Dockerfile b/backend/python/Dockerfile
index c37fc07..acfc8b1 100644
--- a/backend/python/Dockerfile
+++ b/backend/python/Dockerfile
@@ -1,12 +1,12 @@
-FROM python:3.7
-
-WORKDIR /app
-
-COPY requirements.txt ./
-RUN pip install -r requirements.txt
-
-COPY . ./app
-VOLUME file_uploads:/var/lib/file_uploads
-
-EXPOSE 5000
-ENTRYPOINT ["python", "server.py"]
+FROM python:3.7
+
+WORKDIR /app
+
+COPY requirements.txt ./
+RUN pip install -r requirements.txt
+
+COPY . ./app
+VOLUME file_uploads:/var/lib/file_uploads
+
+EXPOSE 5000
+ENTRYPOINT ["python", "server.py"]
diff --git a/backend/python/app/__init__.py b/backend/python/app/__init__.py
index 198ebc4..be71270 100644
--- a/backend/python/app/__init__.py
+++ b/backend/python/app/__init__.py
@@ -1,61 +1,61 @@
-import os
-import firebase_admin
-
-from flask import Flask
-from flask_cors import CORS
-from flask_sqlalchemy import SQLAlchemy
-from logging.config import dictConfig
-
-from .config import app_config
-
-
-def create_app(config_name):
-    # configure Flask logger
-    dictConfig(
-        {
-            "version": 1,
-            "handlers": {
-                "wsgi": {
-                    "class": "logging.FileHandler",
-                    "level": "ERROR",
-                    "filename": "error.log",
-                    "formatter": "default",
-                }
-            },
-            "formatters": {
-                "default": {
-                    "format": "%(asctime)s-%(levelname)s-%(name)s::%(module)s,%(lineno)s: %(message)s"
-                },
-            },
-            "root": {"level": "ERROR", "handlers": ["wsgi"]},
-        }
-    )
-
-    app = Flask(__name__)
-    app.config.from_object(app_config[config_name])
-
-    app.config["CORS_ORIGINS"] = ["http://localhost:3000"]
-    app.config["CORS_SUPPORTS_CREDENTIALS"] = True
-    CORS(app)
-
-    app.config[
-        "SQLALCHEMY_DATABASE_URI"
-    ] = "postgres://{username}:{password}@{host}:5432/{db}".format(
-        username=os.getenv("POSTGRES_USER"),
-        password=os.getenv("POSTGRES_PASSWORD"),
-        host=os.getenv("DB_HOST"),
-        db=os.getenv("POSTGRES_DB"),
-    )
-    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
-
-    firebase_admin.initialize_app()
-
-    from . import models, rest
-
-    models.init_app(app)
-    rest.init_app(app)
-
-    from . import graphql
-    graphql.init_app(app)
-
-    return app
+import os
+import firebase_admin
+
+from flask import Flask
+from flask_cors import CORS
+from flask_sqlalchemy import SQLAlchemy
+from logging.config import dictConfig
+
+from .config import app_config
+
+
+def create_app(config_name):
+    # configure Flask logger
+    dictConfig(
+        {
+            "version": 1,
+            "handlers": {
+                "wsgi": {
+                    "class": "logging.FileHandler",
+                    "level": "ERROR",
+                    "filename": "error.log",
+                    "formatter": "default",
+                }
+            },
+            "formatters": {
+                "default": {
+                    "format": "%(asctime)s-%(levelname)s-%(name)s::%(module)s,%(lineno)s: %(message)s"
+                },
+            },
+            "root": {"level": "ERROR", "handlers": ["wsgi"]},
+        }
+    )
+
+    app = Flask(__name__)
+    app.config.from_object(app_config[config_name])
+
+    app.config["CORS_ORIGINS"] = ["http://localhost:3000"]
+    app.config["CORS_SUPPORTS_CREDENTIALS"] = True
+    CORS(app)
+
+    app.config[
+        "SQLALCHEMY_DATABASE_URI"
+    ] = "postgres://{username}:{password}@{host}:5432/{db}".format(
+        username=os.getenv("POSTGRES_USER"),
+        password=os.getenv("POSTGRES_PASSWORD"),
+        host=os.getenv("DB_HOST"),
+        db=os.getenv("POSTGRES_DB"),
+    )
+    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
+
+    firebase_admin.initialize_app()
+
+    from . import models, rest
+
+    models.init_app(app)
+    rest.init_app(app)
+
+    from . import graphql
+    graphql.init_app(app)
+
+    return app
diff --git a/backend/python/app/graphql/__init__.py b/backend/python/app/graphql/__init__.py
index f0c7327..fffe428 100644
--- a/backend/python/app/graphql/__init__.py
+++ b/backend/python/app/graphql/__init__.py
@@ -1,16 +1,16 @@
-from ..models import db
-from .schema import schema
-from ..services.implementations.entity_service import EntityService
-from .service import services
-
-from flask_graphql import GraphQLView
-from flask import current_app
-
-def init_app(app):
-    app.add_url_rule(
-        "/graphql", view_func=GraphQLView.as_view(
-            "graphql", schema=schema, graphiql=True,
-            context= {"session": db.session})
-    )
-
-    services["entity"] = EntityService(current_app.logger)
+from ..models import db
+from .schema import schema
+from ..services.implementations.entity_service import EntityService
+from .service import services
+
+from flask_graphql import GraphQLView
+from flask import current_app
+
+def init_app(app):
+    app.add_url_rule(
+        "/graphql", view_func=GraphQLView.as_view(
+            "graphql", schema=schema, graphiql=True,
+            context= {"session": db.session})
+    )
+
+    services["entity"] = EntityService(current_app.logger)
diff --git a/backend/python/app/graphql/mutations/auth_mutation.py b/backend/python/app/graphql/mutations/auth_mutation.py
index 23491b2..ee560d2 100644
--- a/backend/python/app/graphql/mutations/auth_mutation.py
+++ b/backend/python/app/graphql/mutations/auth_mutation.py
@@ -1,8 +1,8 @@
-'''
-TODO mutations:
-    login(email: String!, password: String!): AuthDTO!
-    refresh: String!
-    logout(userId: ID!): ID
-    resetPassword(email: String!): Boolean!
- '''
+'''
+TODO mutations:
+    login(email: String!, password: String!): AuthDTO!
+    refresh: String!
+    logout(userId: ID!): ID
+    resetPassword(email: String!): Boolean!
+ '''
  
\ No newline at end of file
diff --git a/backend/python/app/graphql/mutations/entity_mutation.py b/backend/python/app/graphql/mutations/entity_mutation.py
index 6ece2d8..47bdde0 100644
--- a/backend/python/app/graphql/mutations/entity_mutation.py
+++ b/backend/python/app/graphql/mutations/entity_mutation.py
@@ -1,20 +1,20 @@
-from ..types.entity_type import EntityResponseDTO, EntityRequestDTO
-from ..service import services
-
-import graphene
-
-class CreateEntity(graphene.Mutation):
-    class Arguments:
-        entity_data = EntityRequestDTO(required=True)
-        
-    ok = graphene.Boolean()
-    entity = graphene.Field(lambda: EntityResponseDTO)
-
-    def mutate(root, info, entity_data=None):
-        entity_response = services["entity"].create_entity(entity_data) 
-        ok = True
-        return CreateEntity(entity=entity_response, ok=ok)
-
-# optional TODO: 
-# updateEntity(id: ID!, entity: EntityRequestDTO!): EntityResponseDTO!
-# deleteEntity(id: ID!): ID 
+from ..types.entity_type import EntityResponseDTO, EntityRequestDTO
+from ..service import services
+
+import graphene
+
+class CreateEntity(graphene.Mutation):
+    class Arguments:
+        entity_data = EntityRequestDTO(required=True)
+        
+    ok = graphene.Boolean()
+    entity = graphene.Field(lambda: EntityResponseDTO)
+
+    def mutate(root, info, entity_data=None):
+        entity_response = services["entity"].create_entity(entity_data) 
+        ok = True
+        return CreateEntity(entity=entity_response, ok=ok)
+
+# optional TODO: 
+# updateEntity(id: ID!, entity: EntityRequestDTO!): EntityResponseDTO!
+# deleteEntity(id: ID!): ID 
diff --git a/backend/python/app/graphql/mutations/user_mutation.py b/backend/python/app/graphql/mutations/user_mutation.py
index ce0c498..a54abb5 100644
--- a/backend/python/app/graphql/mutations/user_mutation.py
+++ b/backend/python/app/graphql/mutations/user_mutation.py
@@ -1,24 +1,24 @@
-from ..types.user_type import CreateUserDTO, UserDTO
-from ..service import services
-
-import graphene
-
-class CreateUser(graphene.Mutation):
-    class Arguments:
-        user_data = CreateUserDTO(required=True)
-        
-    ok = graphene.Boolean()
-    user = graphene.Field(lambda: UserDTO)
-
-    def mutate(root, info, user_data=None):
-        user_response = services["user"].create_user(user_data).__dict__
-        ok = True
-        return CreateUser(user=user_response, ok=ok)
-
-'''
-TODO mutations:
- updateUser(id: ID!, user: UpdateUserDTO!): UserDTO!
- deleteUserById(id: ID!): ID
- deleteUserByEmail(email: String!): IDdeleteUserById
- deleteUserByEmail
-'''
+from ..types.user_type import CreateUserDTO, UserDTO
+from ..service import services
+
+import graphene
+
+class CreateUser(graphene.Mutation):
+    class Arguments:
+        user_data = CreateUserDTO(required=True)
+        
+    ok = graphene.Boolean()
+    user = graphene.Field(lambda: UserDTO)
+
+    def mutate(root, info, user_data=None):
+        user_response = services["user"].create_user(user_data).__dict__
+        ok = True
+        return CreateUser(user=user_response, ok=ok)
+
+'''
+TODO mutations:
+ updateUser(id: ID!, user: UpdateUserDTO!): UserDTO!
+ deleteUserById(id: ID!): ID
+ deleteUserByEmail(email: String!): IDdeleteUserById
+ deleteUserByEmail
+'''
diff --git a/backend/python/app/graphql/queries/entity_query.py b/backend/python/app/graphql/queries/entity_query.py
index a0e8548..f2149c3 100644
--- a/backend/python/app/graphql/queries/entity_query.py
+++ b/backend/python/app/graphql/queries/entity_query.py
@@ -1,4 +1,4 @@
-from ..service import services
-
-def resolve_entities(root, info, **kwargs):
+from ..service import services
+
+def resolve_entities(root, info, **kwargs):
     return services['entity'].get_entities()
\ No newline at end of file
diff --git a/backend/python/app/graphql/queries/user_query.py b/backend/python/app/graphql/queries/user_query.py
index d96df49..d15e5b6 100644
--- a/backend/python/app/graphql/queries/user_query.py
+++ b/backend/python/app/graphql/queries/user_query.py
@@ -1,11 +1,11 @@
-from ..service import services
-
-def resolve_users(root, info, **kwargs):
-    return services['user'].get_users()
-
-'''
-Required queries:
- userById(id: ID!): UserDTO!
- userByEmail(email: String!): UserDTO!
- users: [UserDTO!]!user
-'''
+from ..service import services
+
+def resolve_users(root, info, **kwargs):
+    return services['user'].get_users()
+
+'''
+Required queries:
+ userById(id: ID!): UserDTO!
+ userByEmail(email: String!): UserDTO!
+ users: [UserDTO!]!user
+'''
diff --git a/backend/python/app/graphql/schema.py b/backend/python/app/graphql/schema.py
index 40548eb..c21b47d 100644
--- a/backend/python/app/graphql/schema.py
+++ b/backend/python/app/graphql/schema.py
@@ -1,25 +1,25 @@
-from .types.entity_type import EntityResponseDTO
-from .types.user_type import UserDTO
-from .mutations.entity_mutation import CreateEntity
-from .mutations.user_mutation import CreateUser
-from .service import services
-from .queries.entity_query import resolve_entities
-from .queries.user_query import resolve_users
-
-import graphene
-
-class Mutation(graphene.ObjectType):
-    create_entity = CreateEntity.Field()
-    create_user = CreateUser.Field()
-     
-class Query(graphene.ObjectType):
-    entities = graphene.Field(graphene.List(EntityResponseDTO))
-    users = graphene.Field(graphene.List(UserDTO))  
-    
-    def resolve_entities(root, info, **kwargs):
-        return resolve_entities(root, info, **kwargs)
-
-    def resolve_users(root, info, **kwargs):
-        return resolve_users(root, info, **kwargs)
-
-schema = graphene.Schema(query=Query, mutation=Mutation)
+from .types.entity_type import EntityResponseDTO
+from .types.user_type import UserDTO
+from .mutations.entity_mutation import CreateEntity
+from .mutations.user_mutation import CreateUser
+from .service import services
+from .queries.entity_query import resolve_entities
+from .queries.user_query import resolve_users
+
+import graphene
+
+class Mutation(graphene.ObjectType):
+    create_entity = CreateEntity.Field()
+    create_user = CreateUser.Field()
+     
+class Query(graphene.ObjectType):
+    entities = graphene.Field(graphene.List(EntityResponseDTO))
+    users = graphene.Field(graphene.List(UserDTO))  
+    
+    def resolve_entities(root, info, **kwargs):
+        return resolve_entities(root, info, **kwargs)
+
+    def resolve_users(root, info, **kwargs):
+        return resolve_users(root, info, **kwargs)
+
+schema = graphene.Schema(query=Query, mutation=Mutation)
diff --git a/backend/python/app/graphql/service.py b/backend/python/app/graphql/service.py
index a00fc6b..44f535b 100644
--- a/backend/python/app/graphql/service.py
+++ b/backend/python/app/graphql/service.py
@@ -1,12 +1,12 @@
-'''
-..services.implementations can only be leveraged once the 
-flask app has started. Create dummy services here that will be
-updated with live app loggers during __init__.py
-'''
-from ..services.implementations.entity_service import EntityService
-from ..services.implementations.user_service import UserService
-
-services = {
-    "entity": EntityService(),
-    "user": UserService(),
+'''
+..services.implementations can only be leveraged once the 
+flask app has started. Create dummy services here that will be
+updated with live app loggers during __init__.py
+'''
+from ..services.implementations.entity_service import EntityService
+from ..services.implementations.user_service import UserService
+
+services = {
+    "entity": EntityService(),
+    "user": UserService(),
 }
\ No newline at end of file
diff --git a/backend/python/app/graphql/types/entity_type.py b/backend/python/app/graphql/types/entity_type.py
index a69891b..81f6006 100644
--- a/backend/python/app/graphql/types/entity_type.py
+++ b/backend/python/app/graphql/types/entity_type.py
@@ -1,22 +1,22 @@
-import graphene
-
-class EntityEnum(graphene.Enum):
-    A = "A"
-    B = "B"
-    C = "C"
-    D = "D"
-
-class EntityResponseDTO(graphene.ObjectType):
-    id = graphene.Int()
-    string_field = graphene.String(required=True)
-    int_field = graphene.Int(required=True)
-    string_array_field = graphene.List(graphene.String, required=True)
-    enum_field = graphene.Field(EntityEnum, required=True)
-    bool_field = graphene.Boolean(required=True)
-
-class EntityRequestDTO(graphene.InputObjectType):
-    string_field = graphene.String(required=True)
-    int_field = graphene.Int(required=True)
-    string_array_field = graphene.List(graphene.String, required=True)
-    enum_field = graphene.Argument(EntityEnum, required=True) 
-    bool_field = graphene.Boolean(required=True)
+import graphene
+
+class EntityEnum(graphene.Enum):
+    A = "A"
+    B = "B"
+    C = "C"
+    D = "D"
+
+class EntityResponseDTO(graphene.ObjectType):
+    id = graphene.Int()
+    string_field = graphene.String(required=True)
+    int_field = graphene.Int(required=True)
+    string_array_field = graphene.List(graphene.String, required=True)
+    enum_field = graphene.Field(EntityEnum, required=True)
+    bool_field = graphene.Boolean(required=True)
+
+class EntityRequestDTO(graphene.InputObjectType):
+    string_field = graphene.String(required=True)
+    int_field = graphene.Int(required=True)
+    string_array_field = graphene.List(graphene.String, required=True)
+    enum_field = graphene.Argument(EntityEnum, required=True) 
+    bool_field = graphene.Boolean(required=True)
diff --git a/backend/python/app/graphql/types/user_type.py b/backend/python/app/graphql/types/user_type.py
index 36c9fe4..9e8ae7a 100644
--- a/backend/python/app/graphql/types/user_type.py
+++ b/backend/python/app/graphql/types/user_type.py
@@ -1,19 +1,19 @@
-import graphene 
-
-class RoleEnum(graphene.Enum):
-    User = "User"
-    Admin = "Admin"
-
-class UserDTO(graphene.ObjectType):
-    id = graphene.Int()
-    first_name = graphene.String(required=True)
-    last_name = graphene.String(required=True)
-    role = graphene.Field(RoleEnum, required=True)
-    email = graphene.String(required=True)
-
-class CreateUserDTO(graphene.InputObjectType):
-    first_name = graphene.String(required=True)
-    last_name = graphene.String(required=True)
-    role = graphene.Argument(RoleEnum, required=True)
-    email = graphene.String(required=True)
-    password = graphene.String(required=True)
+import graphene 
+
+class RoleEnum(graphene.Enum):
+    User = "User"
+    Admin = "Admin"
+
+class UserDTO(graphene.ObjectType):
+    id = graphene.Int()
+    first_name = graphene.String(required=True)
+    last_name = graphene.String(required=True)
+    role = graphene.Field(RoleEnum, required=True)
+    email = graphene.String(required=True)
+
+class CreateUserDTO(graphene.InputObjectType):
+    first_name = graphene.String(required=True)
+    last_name = graphene.String(required=True)
+    role = graphene.Argument(RoleEnum, required=True)
+    email = graphene.String(required=True)
+    password = graphene.String(required=True)
diff --git a/backend/python/app/models/__init__.py b/backend/python/app/models/__init__.py
index 1514a3e..b4ad1bd 100644
--- a/backend/python/app/models/__init__.py
+++ b/backend/python/app/models/__init__.py
@@ -1,22 +1,22 @@
-from flask_sqlalchemy import SQLAlchemy
-
-db = SQLAlchemy()
-erase_db_and_sync = False
-
-
-def init_app(app):
-    from .entity import Entity
-    from .user import User
-    from .story import Story
-    from .file import File
-
-    app.app_context().push()
-    db.init_app(app)
-
-    if erase_db_and_sync:
-        # drop tables
-        db.reflect()
-        db.drop_all()
-
-        # recreate tables
-        db.create_all()
+from flask_sqlalchemy import SQLAlchemy
+
+db = SQLAlchemy()
+erase_db_and_sync = False
+
+
+def init_app(app):
+    from .entity import Entity
+    from .user import User
+    from .story import Story
+    from .file import File
+
+    app.app_context().push()
+    db.init_app(app)
+
+    if erase_db_and_sync:
+        # drop tables
+        db.reflect()
+        db.drop_all()
+
+        # recreate tables
+        db.create_all()
diff --git a/backend/python/app/models/file.py b/backend/python/app/models/file.py
index e3e1629..8cb5399 100644
--- a/backend/python/app/models/file.py
+++ b/backend/python/app/models/file.py
@@ -1,24 +1,24 @@
-from sqlalchemy import inspect
-from sqlalchemy.orm.properties import ColumnProperty
-
-from . import db
-
-
-class File(db.Model):
-    __tablename__ = "files"
-
-    id = db.Column(db.Integer, primary_key=True, nullable=False)
-    path = db.Column(db.String(255), nullable=False)
-
-    def to_dict(self, include_relationships=False):
-        cls = type(self)
-        mapper = inspect(cls)
-        formatted = {}
-        for column in mapper.attrs:
-            field = column.key
-            attr = getattr(self, field)
-            if isinstance(column, ColumnProperty):
-                formatted[field] = attr
-            elif include_relationships:
-                formatted[field] = [obj.to_dict() for obj in attr]
-        return formatted
+from sqlalchemy import inspect
+from sqlalchemy.orm.properties import ColumnProperty
+
+from . import db
+
+
+class File(db.Model):
+    __tablename__ = "files"
+
+    id = db.Column(db.Integer, primary_key=True, nullable=False)
+    path = db.Column(db.String(255), nullable=False)
+
+    def to_dict(self, include_relationships=False):
+        cls = type(self)
+        mapper = inspect(cls)
+        formatted = {}
+        for column in mapper.attrs:
+            field = column.key
+            attr = getattr(self, field)
+            if isinstance(column, ColumnProperty):
+                formatted[field] = attr
+            elif include_relationships:
+                formatted[field] = [obj.to_dict() for obj in attr]
+        return formatted
diff --git a/backend/python/app/models/story.py b/backend/python/app/models/story.py
index 4ae33d7..f695080 100644
--- a/backend/python/app/models/story.py
+++ b/backend/python/app/models/story.py
@@ -1,11 +1,11 @@
-from sqlalchemy import inspect
-from sqlalchemy.orm.properties import ColumnProperty
-
-from . import db
-
-stages_enum = db.Enum("START", "TRANSLATE", "REVIEW", "PUBLISH", name="stages" )
-
-class Story(db.Model):
-    __tablename__ = "stories"
-    id = db.Column(db.Integer, primary_key=True, nullable=False)
-    stage = db.Column(stages_enum, nullable=False)
+from sqlalchemy import inspect
+from sqlalchemy.orm.properties import ColumnProperty
+
+from . import db
+
+stages_enum = db.Enum("START", "TRANSLATE", "REVIEW", "PUBLISH", name="stages" )
+
+class Story(db.Model):
+    __tablename__ = "stories"
+    id = db.Column(db.Integer, primary_key=True, nullable=False)
+    stage = db.Column(stages_enum, nullable=False)
diff --git a/backend/python/app/resources/file_dto.py b/backend/python/app/resources/file_dto.py
index 7733249..e3966be 100644
--- a/backend/python/app/resources/file_dto.py
+++ b/backend/python/app/resources/file_dto.py
@@ -1,6 +1,6 @@
-class FileDTO(object):
-    def __init__(self, path):
-        if not path:
-            raise ValueError("Invalid path value, must not be empty")
-
-        self.path = path
+class FileDTO(object):
+    def __init__(self, path):
+        if not path:
+            raise ValueError("Invalid path value, must not be empty")
+
+        self.path = path
diff --git a/backend/python/app/rest/__init__.py b/backend/python/app/rest/__init__.py
index 73ca801..5bc8634 100644
--- a/backend/python/app/rest/__init__.py
+++ b/backend/python/app/rest/__init__.py
@@ -1,7 +1,7 @@
-def init_app(app):
-    from . import user_routes, auth_routes, entity_routes, file_routes
-
-    app.register_blueprint(user_routes.blueprint)
-    app.register_blueprint(auth_routes.blueprint)
-    app.register_blueprint(entity_routes.blueprint)
-    app.register_blueprint(file_routes.blueprint)
+def init_app(app):
+    from . import user_routes, auth_routes, entity_routes, file_routes
+
+    app.register_blueprint(user_routes.blueprint)
+    app.register_blueprint(auth_routes.blueprint)
+    app.register_blueprint(entity_routes.blueprint)
+    app.register_blueprint(file_routes.blueprint)
diff --git a/backend/python/app/rest/auth_routes.py b/backend/python/app/rest/auth_routes.py
index e57504d..44eba0b 100644
--- a/backend/python/app/rest/auth_routes.py
+++ b/backend/python/app/rest/auth_routes.py
@@ -1,107 +1,107 @@
-import os
-
-from flask import Blueprint, current_app, jsonify, request
-
-from ..middlewares.auth import (
-    require_authorization_by_user_id,
-    require_authorization_by_email,
-)
-from ..services.implementations.auth_service import AuthService
-from ..services.implementations.email_service import EmailService
-from ..services.implementations.user_service import UserService
-
-
-user_service = UserService(current_app.logger)
-email_service = EmailService(
-    current_app.logger,
-    {
-        "refresh_token": os.getenv("EMAIL_REFRESH_TOKEN"),
-        "token_uri": "https://oauth2.googleapis.com/token",
-        "client_id": os.getenv("EMAIL_CLIENT_ID"),
-        "client_secret": os.getenv("EMAIL_CLIENT_SECRET"),
-    },
-    "planetread@uwblueprint.org",  # must replace
-    "Planet Read",  # must replace
-)
-auth_service = AuthService(current_app.logger, user_service, email_service)
-blueprint = Blueprint("auth", __name__, url_prefix="/auth")
-
-
-@blueprint.route("/login", methods=["POST"], strict_slashes=False)
-def login():
-    """
-    Returns access token in response body and sets refreshToken as an httpOnly cookie
-    """
-    try:
-        auth_dto = auth_service.generate_token(
-            request.json["email"], request.json["password"]
-        )
-        response = jsonify(
-            {
-                "access_token": auth_dto.access_token,
-                "id": auth_dto.id,
-                "first_name": auth_dto.first_name,
-                "last_name": auth_dto.last_name,
-                "email": auth_dto.email,
-                "role": auth_dto.role,
-            }
-        )
-        response.set_cookie(
-            "refreshToken",
-            value=auth_dto.refresh_token,
-            httponly=True,
-            secure=(os.getenv("FLASK_CONFIG") == "production"),
-        )
-        return response, 200
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
-
-
-@blueprint.route("/refresh", methods=["POST"], strict_slashes=False)
-def refresh():
-    """
-    Returns access token in response body and sets refreshToken as an httpOnly cookie
-    """
-    try:
-        token = auth_service.renew_token(request.cookies.get("refreshToken"))
-        response = jsonify({"access_token": token.access_token})
-        response.set_cookie(
-            "refreshToken",
-            value=token.refresh_token,
-            httponly=True,
-            secure=(os.getenv("FLASK_CONFIG") == "production"),
-        )
-        return response, 200
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
-
-
-@blueprint.route("/logout/<string:user_id>", methods=["POST"], strict_slashes=False)
-@require_authorization_by_user_id("user_id")
-def logout(user_id):
-    """
-    Revokes all of the specified user's refresh tokens
-    """
-    try:
-        auth_service.revoke_tokens(user_id)
-        return "", 204
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
-
-
-@blueprint.route(
-    "/resetPassword/<string:email>", methods=["POST"], strict_slashes=False
-)
-def reset_password(email):
-    """
-    Triggers password reset for user with specified email (reset link will be emailed)
-    """
-    try:
-        auth_service.reset_password(email)
-        return "", 204
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
+import os
+
+from flask import Blueprint, current_app, jsonify, request
+
+from ..middlewares.auth import (
+    require_authorization_by_user_id,
+    require_authorization_by_email,
+)
+from ..services.implementations.auth_service import AuthService
+from ..services.implementations.email_service import EmailService
+from ..services.implementations.user_service import UserService
+
+
+user_service = UserService(current_app.logger)
+email_service = EmailService(
+    current_app.logger,
+    {
+        "refresh_token": os.getenv("EMAIL_REFRESH_TOKEN"),
+        "token_uri": "https://oauth2.googleapis.com/token",
+        "client_id": os.getenv("EMAIL_CLIENT_ID"),
+        "client_secret": os.getenv("EMAIL_CLIENT_SECRET"),
+    },
+    "planetread@uwblueprint.org",  # must replace
+    "Planet Read",  # must replace
+)
+auth_service = AuthService(current_app.logger, user_service, email_service)
+blueprint = Blueprint("auth", __name__, url_prefix="/auth")
+
+
+@blueprint.route("/login", methods=["POST"], strict_slashes=False)
+def login():
+    """
+    Returns access token in response body and sets refreshToken as an httpOnly cookie
+    """
+    try:
+        auth_dto = auth_service.generate_token(
+            request.json["email"], request.json["password"]
+        )
+        response = jsonify(
+            {
+                "access_token": auth_dto.access_token,
+                "id": auth_dto.id,
+                "first_name": auth_dto.first_name,
+                "last_name": auth_dto.last_name,
+                "email": auth_dto.email,
+                "role": auth_dto.role,
+            }
+        )
+        response.set_cookie(
+            "refreshToken",
+            value=auth_dto.refresh_token,
+            httponly=True,
+            secure=(os.getenv("FLASK_CONFIG") == "production"),
+        )
+        return response, 200
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
+
+
+@blueprint.route("/refresh", methods=["POST"], strict_slashes=False)
+def refresh():
+    """
+    Returns access token in response body and sets refreshToken as an httpOnly cookie
+    """
+    try:
+        token = auth_service.renew_token(request.cookies.get("refreshToken"))
+        response = jsonify({"access_token": token.access_token})
+        response.set_cookie(
+            "refreshToken",
+            value=token.refresh_token,
+            httponly=True,
+            secure=(os.getenv("FLASK_CONFIG") == "production"),
+        )
+        return response, 200
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
+
+
+@blueprint.route("/logout/<string:user_id>", methods=["POST"], strict_slashes=False)
+@require_authorization_by_user_id("user_id")
+def logout(user_id):
+    """
+    Revokes all of the specified user's refresh tokens
+    """
+    try:
+        auth_service.revoke_tokens(user_id)
+        return "", 204
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
+
+
+@blueprint.route(
+    "/resetPassword/<string:email>", methods=["POST"], strict_slashes=False
+)
+def reset_password(email):
+    """
+    Triggers password reset for user with specified email (reset link will be emailed)
+    """
+    try:
+        auth_service.reset_password(email)
+        return "", 204
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
diff --git a/backend/python/app/rest/file_routes.py b/backend/python/app/rest/file_routes.py
index 6713962..3df9202 100644
--- a/backend/python/app/rest/file_routes.py
+++ b/backend/python/app/rest/file_routes.py
@@ -1,54 +1,54 @@
-import os
-from werkzeug.utils import secure_filename
-
-from flask import Blueprint, current_app, request
-from flask import jsonify
-
-from ..resources.file_dto import FileDTO
-
-from ..middlewares.auth import require_authorization_by_role
-from ..services.implementations.file_service import FileService
-
-# define instance of fileService
-file_service = FileService(current_app.logger)
-
-# defines a shared URL prefix for all routes
-blueprint = Blueprint("file", __name__, url_prefix="/files")
-
-
-@blueprint.route("/<int:id>", methods=["GET"], strict_slashes=False)
-@require_authorization_by_role({"User", "Admin"})
-def get_file(id):
-    try:
-        result = file_service.get_file(id)
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
-
-    return jsonify(result), 200
-
-
-@blueprint.route("/", methods=["POST"], strict_slashes=False)
-@require_authorization_by_role({"User", "Admin"})
-def create_file():
-    try:
-        if "file" not in request.files:
-            return jsonify({"error": "No file provided"}), 400
-        file = request.files["file"]
-        if file.filename == "":
-            return jsonify({"error": "No file provided"}), 400
-
-        upload_folder_path = os.getenv("UPLOAD_PATH")
-        upload_path = os.path.join(upload_folder_path, secure_filename(file.filename))
-        # rename file if it already exists
-        if os.path.isfile(upload_path):
-            upload_path = file_service.generate_file_name(
-                secure_filename(file.filename)
-            )
-        file.save(upload_path)
-        file_dto = FileDTO(upload_path)
-        res = file_service.create_file(file_dto)
-        return jsonify(res), 201
-    except Exception as e:
-        error_message = getattr(e, "message", None)
-        return jsonify({"error": (error_message if error_message else str(e))}), 500
+import os
+from werkzeug.utils import secure_filename
+
+from flask import Blueprint, current_app, request
+from flask import jsonify
+
+from ..resources.file_dto import FileDTO
+
+from ..middlewares.auth import require_authorization_by_role
+from ..services.implementations.file_service import FileService
+
+# define instance of fileService
+file_service = FileService(current_app.logger)
+
+# defines a shared URL prefix for all routes
+blueprint = Blueprint("file", __name__, url_prefix="/files")
+
+
+@blueprint.route("/<int:id>", methods=["GET"], strict_slashes=False)
+@require_authorization_by_role({"User", "Admin"})
+def get_file(id):
+    try:
+        result = file_service.get_file(id)
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
+
+    return jsonify(result), 200
+
+
+@blueprint.route("/", methods=["POST"], strict_slashes=False)
+@require_authorization_by_role({"User", "Admin"})
+def create_file():
+    try:
+        if "file" not in request.files:
+            return jsonify({"error": "No file provided"}), 400
+        file = request.files["file"]
+        if file.filename == "":
+            return jsonify({"error": "No file provided"}), 400
+
+        upload_folder_path = os.getenv("UPLOAD_PATH")
+        upload_path = os.path.join(upload_folder_path, secure_filename(file.filename))
+        # rename file if it already exists
+        if os.path.isfile(upload_path):
+            upload_path = file_service.generate_file_name(
+                secure_filename(file.filename)
+            )
+        file.save(upload_path)
+        file_dto = FileDTO(upload_path)
+        res = file_service.create_file(file_dto)
+        return jsonify(res), 201
+    except Exception as e:
+        error_message = getattr(e, "message", None)
+        return jsonify({"error": (error_message if error_message else str(e))}), 500
diff --git a/backend/python/app/services/implementations/entity_service.py b/backend/python/app/services/implementations/entity_service.py
index a505d3d..eba56ea 100644
--- a/backend/python/app/services/implementations/entity_service.py
+++ b/backend/python/app/services/implementations/entity_service.py
@@ -1,57 +1,57 @@
-from ...models.entity import Entity
-from ...models import db
-from ..interfaces.entity_service import IEntityService
-
-from flask import current_app
-
-class EntityService(IEntityService):
-    def __init__(self, logger=current_app.logger):
-        self.logger = logger
-
-    def get_entities(self):
-        # Entity is a SQLAlchemy model, we can use convenient methods provided
-        # by SQLAlchemy like query.all() to query the data
-        return [result.to_dict() for result in Entity.query.all()]
-
-    def get_entity(self, id):
-        # get queries by the primary key, which is id for the Entity table
-        entity = Entity.query.get(id)
-        if entity is None:
-            self.logger.error("Invalid id")
-            raise Exception("Invalid id")
-        return entity.to_dict()
-
-    def create_entity(self, entity):
-        try:
-            new_entity = Entity(**entity.__dict__)
-        except Exception as error:
-            self.logger.error(str(error))
-            raise error
-
-        db.session.add(new_entity)
-        # remember to commit to actually persist into the database
-        db.session.commit()
-
-        return new_entity
-
-    def update_entity(self, id, entity):
-        Entity.query.filter_by(id=id).update(entity.__dict__)
-        updated_entity = Entity.query.get(id)
-        db.session.commit()
-
-        if updated_entity is None:
-            self.logger.error("Invalid id")
-            raise Exception("Invalid id")
-        return updated_entity.to_dict()
-
-    def delete_entity(self, id):
-        deleted = Entity.query.filter_by(id=id).delete()
-        db.session.commit()
-
-        # deleted is the number of rows deleted
-        if deleted == 1:
-            return id
-
-        self.logger.error("Invalid id")
-        raise Exception("Invalid id")
-
+from ...models.entity import Entity
+from ...models import db
+from ..interfaces.entity_service import IEntityService
+
+from flask import current_app
+
+class EntityService(IEntityService):
+    def __init__(self, logger=current_app.logger):
+        self.logger = logger
+
+    def get_entities(self):
+        # Entity is a SQLAlchemy model, we can use convenient methods provided
+        # by SQLAlchemy like query.all() to query the data
+        return [result.to_dict() for result in Entity.query.all()]
+
+    def get_entity(self, id):
+        # get queries by the primary key, which is id for the Entity table
+        entity = Entity.query.get(id)
+        if entity is None:
+            self.logger.error("Invalid id")
+            raise Exception("Invalid id")
+        return entity.to_dict()
+
+    def create_entity(self, entity):
+        try:
+            new_entity = Entity(**entity.__dict__)
+        except Exception as error:
+            self.logger.error(str(error))
+            raise error
+
+        db.session.add(new_entity)
+        # remember to commit to actually persist into the database
+        db.session.commit()
+
+        return new_entity
+
+    def update_entity(self, id, entity):
+        Entity.query.filter_by(id=id).update(entity.__dict__)
+        updated_entity = Entity.query.get(id)
+        db.session.commit()
+
+        if updated_entity is None:
+            self.logger.error("Invalid id")
+            raise Exception("Invalid id")
+        return updated_entity.to_dict()
+
+    def delete_entity(self, id):
+        deleted = Entity.query.filter_by(id=id).delete()
+        db.session.commit()
+
+        # deleted is the number of rows deleted
+        if deleted == 1:
+            return id
+
+        self.logger.error("Invalid id")
+        raise Exception("Invalid id")
+
diff --git a/backend/python/app/services/implementations/file_service.py b/backend/python/app/services/implementations/file_service.py
index 4323478..49f8822 100644
--- a/backend/python/app/services/implementations/file_service.py
+++ b/backend/python/app/services/implementations/file_service.py
@@ -1,43 +1,43 @@
-import os
-
-from ...models.file import File
-from ...models import db
-from ..interfaces.file_service import IFileService
-
-
-class FileService(IFileService):
-    def __init__(self, logger):
-        self.logger = logger
-
-    def get_file(self, id):
-        file = File.query.get(id)
-        if file is None:
-            self.logger.error(f"Invalid id {id}")
-            raise Exception(f"Invalid id {id}")
-        return file.to_dict()
-
-    def generate_file_name(self, filename):
-        # append number to the filename if duplicate filename found
-        suffix = 0
-        upload_folder_path = os.getenv("UPLOAD_PATH")
-        file = os.path.join(upload_folder_path, filename)
-        while os.path.isfile(file):
-            split_filename = filename.split(".", 1)
-            name = f"{split_filename[0]}_{suffix}"
-            new_filename = ".".join([name, split_filename[1]])
-            file = os.path.join(upload_folder_path, new_filename)
-            suffix += 1
-        return file
-
-    def create_file(self, file):
-        try:
-            self.logger.info(file)
-            new_file = File(**file.__dict__)
-        except Exception as error:
-            self.logger.error(str(error))
-            raise error
-
-        db.session.add(new_file)
-        db.session.commit()
-
-        return new_file.to_dict()
+import os
+
+from ...models.file import File
+from ...models import db
+from ..interfaces.file_service import IFileService
+
+
+class FileService(IFileService):
+    def __init__(self, logger):
+        self.logger = logger
+
+    def get_file(self, id):
+        file = File.query.get(id)
+        if file is None:
+            self.logger.error(f"Invalid id {id}")
+            raise Exception(f"Invalid id {id}")
+        return file.to_dict()
+
+    def generate_file_name(self, filename):
+        # append number to the filename if duplicate filename found
+        suffix = 0
+        upload_folder_path = os.getenv("UPLOAD_PATH")
+        file = os.path.join(upload_folder_path, filename)
+        while os.path.isfile(file):
+            split_filename = filename.split(".", 1)
+            name = f"{split_filename[0]}_{suffix}"
+            new_filename = ".".join([name, split_filename[1]])
+            file = os.path.join(upload_folder_path, new_filename)
+            suffix += 1
+        return file
+
+    def create_file(self, file):
+        try:
+            self.logger.info(file)
+            new_file = File(**file.__dict__)
+        except Exception as error:
+            self.logger.error(str(error))
+            raise error
+
+        db.session.add(new_file)
+        db.session.commit()
+
+        return new_file.to_dict()
diff --git a/backend/python/app/services/implementations/user_service.py b/backend/python/app/services/implementations/user_service.py
index ca1ef56..f4ce5ca 100644
--- a/backend/python/app/services/implementations/user_service.py
+++ b/backend/python/app/services/implementations/user_service.py
@@ -1,399 +1,399 @@
-from flask.globals import current_app
-import firebase_admin.auth
-
-from ..interfaces.user_service import IUserService
-from ...models.user import User
-from ...models import db
-from ...resources.user_dto import UserDTO
-
-from flask import current_app
-
-class UserService(IUserService):
-    """
-    UserService implementation with user management methods
-    """
-
-    def __init__(self, logger=current_app.logger):
-        """
-        Create an instance of UserService
-
-        :param logger: application's logger instance
-        :type logger: logger
-        """
-        self.logger = logger
-
-    def get_user_by_id(self, user_id):
-        try:
-            user = User.query.get(user_id)
-
-            if not user:
-                raise Exception("user_id {user_id} not found".format(user_id))
-
-            firebase_user = firebase_admin.auth.get_user(user.auth_id)
-
-            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
-            user_dict["email"] = firebase_user.email
-
-            return UserDTO(**user_dict)
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to get user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def get_user_by_email(self, email):
-        try:
-            firebase_user = firebase_admin.auth.get_user_by_email(email)
-            user = User.query.filter_by(auth_id=firebase_user.uid).first()
-
-            if not user:
-                raise Exception(
-                    "user with auth_id {auth_id} not found".format(
-                        auth_id=firebase_user.uid
-                    )
-                )
-
-            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
-            user_dict["email"] = firebase_user.email
-
-            return UserDTO(**user_dict)
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to get user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def get_user_role_by_auth_id(self, auth_id):
-        try:
-            user = self.__get_user_by_auth_id(auth_id)
-            return user.role
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to get user role. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def get_user_id_by_auth_id(self, auth_id):
-        try:
-            user = self.__get_user_by_auth_id(auth_id)
-            return str(user.id)
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to get user id. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def get_auth_id_by_user_id(self, user_id):
-        try:
-            user = User.query.get(user_id)
-
-            if not user:
-                raise Exception("user_id {user_id} not found".format(user_id=user_id))
-
-            return user.auth_id
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "failed to get auth_id. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def get_users(self):
-        user_dtos = []
-        user_list = [result for result in User.query.all()]
-        for user in user_list:
-            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
-            try:
-                firebase_user = firebase_admin.auth.get_user(user.auth_id)
-                user_dict["email"] = firebase_user.email
-                user_dtos.append(UserDTO(**user_dict))
-            except Exception as e:
-                self.logger.error(
-                    "User with auth_id {auth_id} could not be fetched from Firebase".format(
-                        auth_id=user.auth_id
-                    )
-                )
-                raise e
-
-        return user_dtos
-
-    def create_user(self, user):
-        new_user = None
-        firebase_user = None
-
-        try:
-            firebase_user = firebase_admin.auth.create_user(
-                email=user.email, password=user.password
-            )
-
-            postgres_user = {
-                "first_name": user.first_name,
-                "last_name": user.last_name,
-                "auth_id": firebase_user.uid,
-                "role": user.role,
-            }
-
-            try:
-                new_user = User(**postgres_user)
-                db.session.add(new_user)
-                db.session.commit()
-            except Exception as postgres_error:
-                # rollback user creation in Firebase
-                try:
-                    firebase_admin.auth.delete_user(firebase_user.uid)
-                except Exception as firebase_error:
-                    reason = getattr(firebase_error, "message", None)
-                    error_message = [
-                        "Failed to rollback Firebase user creation after PostgreSQL user creation failed.",
-                        "Reason = {reason},".format(
-                            reason=(reason if reason else str(firebase_error))
-                        ),
-                        "Orphaned auth_id (Firebase uid) = {auth_id}".format(
-                            auth_id=firebase_user.uid
-                        ),
-                    ]
-                    self.logger.error(" ".join(error_message))
-                raise postgres_error
-
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to create user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-        new_user_dict = UserService.__user_to_dict_and_remove_auth_id(new_user)
-        new_user_dict["email"] = firebase_user.email
-        return UserDTO(**new_user_dict)
-
-    def update_user_by_id(self, user_id, user):
-        try:
-            old_user = User.query.get(user_id)
-
-            if not old_user:
-                raise Exception("user_id {user_id} not found".format(user_id=user_id))
-
-            User.query.filter_by(id=user_id).update(
-                {
-                    User.first_name: user.first_name,
-                    User.last_name: user.last_name,
-                    User.role: user.role,
-                }
-            )
-
-            db.session.commit()
-
-            try:
-                firebase_admin.auth.update_user(old_user.auth_id, email=user.email)
-            except Exception as firebase_error:
-                try:
-                    old_user_dict = {
-                        User.first_name: old_user.first_name,
-                        User.last_name: old_user.last_name,
-                        User.role: old_user.role,
-                    }
-                    User.query.filter_by(id=user_id).update(**old_user_dict)
-                    db.session.commit()
-
-                except Exception as postgres_error:
-                    reason = getattr(postgres_error, "message", None)
-                    error_message = [
-                        "Failed to rollback Postgres user update after Firebase user update failure.",
-                        "Reason = {reason},".format(
-                            reason=(reason if reason else str(postgres_error))
-                        ),
-                        "Postgres user id with possibly inconsistent data = {user_id}".format(
-                            user_id=user_id
-                        ),
-                    ]
-                    self.logger.error(" ".join(error_message))
-
-                raise firebase_error
-
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to update user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-        return UserDTO(user_id, user.first_name, user.last_name, user.email, user.role)
-
-    def delete_user_by_id(self, user_id):
-        try:
-            deleted_user = User.query.get(user_id)
-
-            if not deleted_user:
-                raise Exception("user_id {user_id} not found".format(user_id=user_id))
-
-            delete_count = User.query.filter_by(id=user_id).delete(
-                synchronize_session="fetch"
-            )
-
-            if delete_count < 1:
-                raise Exception(
-                    "user_id {user_id} was not deleted".format(user_id=user_id)
-                )
-            elif delete_count > 1:
-                raise Exception(
-                    "user_id {user_id} had multiple instances. Delete not committed.".format(
-                        user_id=user_id
-                    )
-                )
-
-            db.session.commit()
-
-            try:
-                firebase_admin.auth.delete_user(deleted_user.auth_id)
-            except Exception as firebase_error:
-                # rollback Postgres user deletion
-                try:
-                    deleted_user_dict = {
-                        "first_name": deleted_user.first_name,
-                        "last_name": deleted_user.last_name,
-                        "auth_id": deleted_user.auth_id,
-                        "role": deleted_user.role,
-                    }
-
-                    new_user = User(**deleted_user_dict)
-                    db.session.add(new_user)
-                    db.session.commit()
-
-                except Exception as postgres_error:
-                    reason = getattr(postgres_error, "message", None)
-                    error_message = [
-                        "Failed to rollback Postgres user deletion after Firebase user deletion failure.",
-                        "Reason = {reason},".format(
-                            reason=(reason if reason else str(postgres_error)),
-                        ),
-                        "Firebase uid with non-existent Postgres record ={auth_id}".format(
-                            auth_id=deleted_user.auth_id
-                        ),
-                    ]
-                    self.logger.error(" ".join(error_message))
-
-                raise firebase_error
-
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to delete user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def delete_user_by_email(self, email):
-        try:
-            firebase_user = firebase_admin.auth.get_user_by_email(email)
-            deleted_user = User.query.filter_by(auth_id=firebase_user.uid).first()
-
-            if not deleted_user:
-                raise Exception(
-                    "auth_id (Firebase uid) {auth_id} not found".format(
-                        auth_id=firebase_user.uid
-                    )
-                )
-
-            delete_count = User.query.filter_by(auth_id=firebase_user.uid).delete(
-                synchronize_session="fetch"
-            )
-
-            if delete_count < 1:
-                raise Exception(
-                    "user_id {user_id} was not deleted".format(user_id=user_id)
-                )
-            elif delete_count > 1:
-                raise Exception(
-                    "user_id {user_id} had multiple instances. Delete not committed.".format(
-                        user_id=user_id
-                    )
-                )
-
-            db.session.commit()
-
-            try:
-                firebase_admin.auth.delete_user(firebase_user.uid)
-            except Exception as firebase_error:
-                try:
-                    deleted_user_dict = {
-                        "first_name": deleted_user.first_name,
-                        "last_name": deleted_user.last_name,
-                        "auth_id": deleted_user.auth_id,
-                        "role": deleted_user.role,
-                    }
-                    new_user = User(**deleted_user_dict)
-                    db.session.add(new_user)
-                    db.session.commit()
-
-                except Exception as postgres_error:
-                    reason = getattr(postgres_error, "message", None)
-                    error_message = [
-                        "Failed to rollback Postgres user deletion after Firebase user deletion failure.",
-                        "Reason = {reason},".format(
-                            reason=(reason if reason else str(postgres_error))
-                        ),
-                        "Firebase uid with non-existent Postgres record = {auth_id}".format(
-                            auth_id=deleted_user.auth_id
-                        ),
-                    ]
-                    self.logger.error(" ".join(error_message))
-
-                raise firebase_error
-
-        except Exception as e:
-            reason = getattr(e, "message", None)
-            self.logger.error(
-                "Failed to delete user. Reason = {reason}".format(
-                    reason=(reason if reason else str(e))
-                )
-            )
-            raise e
-
-    def __get_user_by_auth_id(self, auth_id):
-        """
-        Get a user document by auth_id
-
-        :param auth_id: the user's auth_id (Firebase uid)
-        :type auth_id: str
-        """
-        user = User.query.filter_by(auth_id=auth_id).first()
-
-        if not user:
-            raise Exception(
-                "user with auth_id {auth_id} not found".format(auth_id=auth_id)
-            )
-
-        return user
-
-    @staticmethod
-    def __user_to_dict_and_remove_auth_id(user):
-        """
-        Convert a User document to a serializable dict and remove the
-        auth id field
-
-        :param user: the user
-        :type user: User
-        """
-        user_dict = user.to_dict()
-        user_dict.pop("auth_id", None)
-        return user_dict
-
+from flask.globals import current_app
+import firebase_admin.auth
+
+from ..interfaces.user_service import IUserService
+from ...models.user import User
+from ...models import db
+from ...resources.user_dto import UserDTO
+
+from flask import current_app
+
+class UserService(IUserService):
+    """
+    UserService implementation with user management methods
+    """
+
+    def __init__(self, logger=current_app.logger):
+        """
+        Create an instance of UserService
+
+        :param logger: application's logger instance
+        :type logger: logger
+        """
+        self.logger = logger
+
+    def get_user_by_id(self, user_id):
+        try:
+            user = User.query.get(user_id)
+
+            if not user:
+                raise Exception("user_id {user_id} not found".format(user_id))
+
+            firebase_user = firebase_admin.auth.get_user(user.auth_id)
+
+            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
+            user_dict["email"] = firebase_user.email
+
+            return UserDTO(**user_dict)
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to get user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def get_user_by_email(self, email):
+        try:
+            firebase_user = firebase_admin.auth.get_user_by_email(email)
+            user = User.query.filter_by(auth_id=firebase_user.uid).first()
+
+            if not user:
+                raise Exception(
+                    "user with auth_id {auth_id} not found".format(
+                        auth_id=firebase_user.uid
+                    )
+                )
+
+            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
+            user_dict["email"] = firebase_user.email
+
+            return UserDTO(**user_dict)
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to get user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def get_user_role_by_auth_id(self, auth_id):
+        try:
+            user = self.__get_user_by_auth_id(auth_id)
+            return user.role
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to get user role. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def get_user_id_by_auth_id(self, auth_id):
+        try:
+            user = self.__get_user_by_auth_id(auth_id)
+            return str(user.id)
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to get user id. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def get_auth_id_by_user_id(self, user_id):
+        try:
+            user = User.query.get(user_id)
+
+            if not user:
+                raise Exception("user_id {user_id} not found".format(user_id=user_id))
+
+            return user.auth_id
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "failed to get auth_id. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def get_users(self):
+        user_dtos = []
+        user_list = [result for result in User.query.all()]
+        for user in user_list:
+            user_dict = UserService.__user_to_dict_and_remove_auth_id(user)
+            try:
+                firebase_user = firebase_admin.auth.get_user(user.auth_id)
+                user_dict["email"] = firebase_user.email
+                user_dtos.append(UserDTO(**user_dict))
+            except Exception as e:
+                self.logger.error(
+                    "User with auth_id {auth_id} could not be fetched from Firebase".format(
+                        auth_id=user.auth_id
+                    )
+                )
+                raise e
+
+        return user_dtos
+
+    def create_user(self, user):
+        new_user = None
+        firebase_user = None
+
+        try:
+            firebase_user = firebase_admin.auth.create_user(
+                email=user.email, password=user.password
+            )
+
+            postgres_user = {
+                "first_name": user.first_name,
+                "last_name": user.last_name,
+                "auth_id": firebase_user.uid,
+                "role": user.role,
+            }
+
+            try:
+                new_user = User(**postgres_user)
+                db.session.add(new_user)
+                db.session.commit()
+            except Exception as postgres_error:
+                # rollback user creation in Firebase
+                try:
+                    firebase_admin.auth.delete_user(firebase_user.uid)
+                except Exception as firebase_error:
+                    reason = getattr(firebase_error, "message", None)
+                    error_message = [
+                        "Failed to rollback Firebase user creation after PostgreSQL user creation failed.",
+                        "Reason = {reason},".format(
+                            reason=(reason if reason else str(firebase_error))
+                        ),
+                        "Orphaned auth_id (Firebase uid) = {auth_id}".format(
+                            auth_id=firebase_user.uid
+                        ),
+                    ]
+                    self.logger.error(" ".join(error_message))
+                raise postgres_error
+
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to create user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+        new_user_dict = UserService.__user_to_dict_and_remove_auth_id(new_user)
+        new_user_dict["email"] = firebase_user.email
+        return UserDTO(**new_user_dict)
+
+    def update_user_by_id(self, user_id, user):
+        try:
+            old_user = User.query.get(user_id)
+
+            if not old_user:
+                raise Exception("user_id {user_id} not found".format(user_id=user_id))
+
+            User.query.filter_by(id=user_id).update(
+                {
+                    User.first_name: user.first_name,
+                    User.last_name: user.last_name,
+                    User.role: user.role,
+                }
+            )
+
+            db.session.commit()
+
+            try:
+                firebase_admin.auth.update_user(old_user.auth_id, email=user.email)
+            except Exception as firebase_error:
+                try:
+                    old_user_dict = {
+                        User.first_name: old_user.first_name,
+                        User.last_name: old_user.last_name,
+                        User.role: old_user.role,
+                    }
+                    User.query.filter_by(id=user_id).update(**old_user_dict)
+                    db.session.commit()
+
+                except Exception as postgres_error:
+                    reason = getattr(postgres_error, "message", None)
+                    error_message = [
+                        "Failed to rollback Postgres user update after Firebase user update failure.",
+                        "Reason = {reason},".format(
+                            reason=(reason if reason else str(postgres_error))
+                        ),
+                        "Postgres user id with possibly inconsistent data = {user_id}".format(
+                            user_id=user_id
+                        ),
+                    ]
+                    self.logger.error(" ".join(error_message))
+
+                raise firebase_error
+
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to update user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+        return UserDTO(user_id, user.first_name, user.last_name, user.email, user.role)
+
+    def delete_user_by_id(self, user_id):
+        try:
+            deleted_user = User.query.get(user_id)
+
+            if not deleted_user:
+                raise Exception("user_id {user_id} not found".format(user_id=user_id))
+
+            delete_count = User.query.filter_by(id=user_id).delete(
+                synchronize_session="fetch"
+            )
+
+            if delete_count < 1:
+                raise Exception(
+                    "user_id {user_id} was not deleted".format(user_id=user_id)
+                )
+            elif delete_count > 1:
+                raise Exception(
+                    "user_id {user_id} had multiple instances. Delete not committed.".format(
+                        user_id=user_id
+                    )
+                )
+
+            db.session.commit()
+
+            try:
+                firebase_admin.auth.delete_user(deleted_user.auth_id)
+            except Exception as firebase_error:
+                # rollback Postgres user deletion
+                try:
+                    deleted_user_dict = {
+                        "first_name": deleted_user.first_name,
+                        "last_name": deleted_user.last_name,
+                        "auth_id": deleted_user.auth_id,
+                        "role": deleted_user.role,
+                    }
+
+                    new_user = User(**deleted_user_dict)
+                    db.session.add(new_user)
+                    db.session.commit()
+
+                except Exception as postgres_error:
+                    reason = getattr(postgres_error, "message", None)
+                    error_message = [
+                        "Failed to rollback Postgres user deletion after Firebase user deletion failure.",
+                        "Reason = {reason},".format(
+                            reason=(reason if reason else str(postgres_error)),
+                        ),
+                        "Firebase uid with non-existent Postgres record ={auth_id}".format(
+                            auth_id=deleted_user.auth_id
+                        ),
+                    ]
+                    self.logger.error(" ".join(error_message))
+
+                raise firebase_error
+
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to delete user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def delete_user_by_email(self, email):
+        try:
+            firebase_user = firebase_admin.auth.get_user_by_email(email)
+            deleted_user = User.query.filter_by(auth_id=firebase_user.uid).first()
+
+            if not deleted_user:
+                raise Exception(
+                    "auth_id (Firebase uid) {auth_id} not found".format(
+                        auth_id=firebase_user.uid
+                    )
+                )
+
+            delete_count = User.query.filter_by(auth_id=firebase_user.uid).delete(
+                synchronize_session="fetch"
+            )
+
+            if delete_count < 1:
+                raise Exception(
+                    "user_id {user_id} was not deleted".format(user_id=user_id)
+                )
+            elif delete_count > 1:
+                raise Exception(
+                    "user_id {user_id} had multiple instances. Delete not committed.".format(
+                        user_id=user_id
+                    )
+                )
+
+            db.session.commit()
+
+            try:
+                firebase_admin.auth.delete_user(firebase_user.uid)
+            except Exception as firebase_error:
+                try:
+                    deleted_user_dict = {
+                        "first_name": deleted_user.first_name,
+                        "last_name": deleted_user.last_name,
+                        "auth_id": deleted_user.auth_id,
+                        "role": deleted_user.role,
+                    }
+                    new_user = User(**deleted_user_dict)
+                    db.session.add(new_user)
+                    db.session.commit()
+
+                except Exception as postgres_error:
+                    reason = getattr(postgres_error, "message", None)
+                    error_message = [
+                        "Failed to rollback Postgres user deletion after Firebase user deletion failure.",
+                        "Reason = {reason},".format(
+                            reason=(reason if reason else str(postgres_error))
+                        ),
+                        "Firebase uid with non-existent Postgres record = {auth_id}".format(
+                            auth_id=deleted_user.auth_id
+                        ),
+                    ]
+                    self.logger.error(" ".join(error_message))
+
+                raise firebase_error
+
+        except Exception as e:
+            reason = getattr(e, "message", None)
+            self.logger.error(
+                "Failed to delete user. Reason = {reason}".format(
+                    reason=(reason if reason else str(e))
+                )
+            )
+            raise e
+
+    def __get_user_by_auth_id(self, auth_id):
+        """
+        Get a user document by auth_id
+
+        :param auth_id: the user's auth_id (Firebase uid)
+        :type auth_id: str
+        """
+        user = User.query.filter_by(auth_id=auth_id).first()
+
+        if not user:
+            raise Exception(
+                "user with auth_id {auth_id} not found".format(auth_id=auth_id)
+            )
+
+        return user
+
+    @staticmethod
+    def __user_to_dict_and_remove_auth_id(user):
+        """
+        Convert a User document to a serializable dict and remove the
+        auth id field
+
+        :param user: the user
+        :type user: User
+        """
+        user_dict = user.to_dict()
+        user_dict.pop("auth_id", None)
+        return user_dict
+
diff --git a/backend/python/app/services/interfaces/file_service.py b/backend/python/app/services/interfaces/file_service.py
index df9d1ab..109b0c1 100644
--- a/backend/python/app/services/interfaces/file_service.py
+++ b/backend/python/app/services/interfaces/file_service.py
@@ -1,29 +1,29 @@
-from abc import ABC, abstractmethod
-
-
-class IFileService(ABC):
-    """
-    A class to handle CRUD functionality for entities
-    """
-
-    @abstractmethod
-    def get_file(self, id):
-        """Return a dictionary from the File object based on id
-
-        :param id: File id
-        :return: dictionary of File object
-        :rtype: dictionary
-        :raises Exception: id retrieval fails
-        """
-        pass
-
-    @abstractmethod
-    def create_file(self, file):
-        """Create a new File object
-
-        :param file: dictionary of file fields
-        :return: dictionary of File object
-        :rtype: dictionary
-        :raises Exception: if file fields are invalid
-        """
-        pass
+from abc import ABC, abstractmethod
+
+
+class IFileService(ABC):
+    """
+    A class to handle CRUD functionality for entities
+    """
+
+    @abstractmethod
+    def get_file(self, id):
+        """Return a dictionary from the File object based on id
+
+        :param id: File id
+        :return: dictionary of File object
+        :rtype: dictionary
+        :raises Exception: id retrieval fails
+        """
+        pass
+
+    @abstractmethod
+    def create_file(self, file):
+        """Create a new File object
+
+        :param file: dictionary of file fields
+        :return: dictionary of File object
+        :rtype: dictionary
+        :raises Exception: if file fields are invalid
+        """
+        pass
diff --git a/backend/python/requirements.txt b/backend/python/requirements.txt
index 5ccaf0d..cad12ad 100644
--- a/backend/python/requirements.txt
+++ b/backend/python/requirements.txt
@@ -1,63 +1,63 @@
-alembic==1.5.2
-appdirs==1.4.4
-black==20.8b1
-CacheControl==0.12.6
-cachetools==4.2.1
-certifi==2020.12.5
-cffi==1.14.5
-chardet==4.0.0
-click==7.1.2
-dnspython==1.16.0
-firebase-admin==4.5.3
-Flask==1.1.2
-Flask-Cors==3.0.10
-Flask-GraphQL==2.0.1
-Flask-SQLAlchemy==2.4.4
-graphene==2.1.8
-google-api-core==1.26.3
-google-api-python-client==2.2.0
-google-auth==1.29.0
-google-auth-httplib2==0.1.0
-googleapis-common-protos==1.53.0
-httplib2==0.19.1
-google-cloud-core==1.6.0
-google-cloud-firestore==2.1.0
-google-cloud-storage==1.37.1
-google-crc32c==1.1.2
-google-resumable-media==1.2.0
-googleapis-common-protos==1.53.0
-grpcio==1.37.0
-httplib2==0.19.1
-idna==2.10
-itsdangerous==1.1.0
-Jinja2==2.11.2
-Mako==1.1.4
-MarkupSafe==1.1.1
-mongoengine==0.23.0
-msgpack==1.0.2
-mypy-extensions==0.4.3
-packaging==20.9
-pathspec==0.8.1
-proto-plus==1.18.1
-protobuf==3.15.8
-psycopg2==2.8.6
-pyasn1==0.4.8
-pyasn1-modules==0.2.8
-pycparser==2.20
-pymongo==3.11.3
-pyparsing==2.4.7
-python-dateutil==2.8.1
-python-dotenv==0.15.0
-python-editor==1.0.4
-pytz==2021.1
-regex==2020.11.13
-requests==2.25.1
-rsa==4.7.2
-six==1.15.0
-SQLAlchemy==1.3.22
-toml==0.10.2
-typed-ast==1.4.2
-typing-extensions==3.7.4.3
-uritemplate==3.0.1
-urllib3==1.26.4
-Werkzeug==1.0.1
+alembic==1.5.2
+appdirs==1.4.4
+black==20.8b1
+CacheControl==0.12.6
+cachetools==4.2.1
+certifi==2020.12.5
+cffi==1.14.5
+chardet==4.0.0
+click==7.1.2
+dnspython==1.16.0
+firebase-admin==4.5.3
+Flask==1.1.2
+Flask-Cors==3.0.10
+Flask-GraphQL==2.0.1
+Flask-SQLAlchemy==2.4.4
+graphene==2.1.8
+google-api-core==1.26.3
+google-api-python-client==2.2.0
+google-auth==1.29.0
+google-auth-httplib2==0.1.0
+googleapis-common-protos==1.53.0
+httplib2==0.19.1
+google-cloud-core==1.6.0
+google-cloud-firestore==2.1.0
+google-cloud-storage==1.37.1
+google-crc32c==1.1.2
+google-resumable-media==1.2.0
+googleapis-common-protos==1.53.0
+grpcio==1.37.0
+httplib2==0.19.1
+idna==2.10
+itsdangerous==1.1.0
+Jinja2==2.11.2
+Mako==1.1.4
+MarkupSafe==1.1.1
+mongoengine==0.23.0
+msgpack==1.0.2
+mypy-extensions==0.4.3
+packaging==20.9
+pathspec==0.8.1
+proto-plus==1.18.1
+protobuf==3.15.8
+psycopg2==2.8.6
+pyasn1==0.4.8
+pyasn1-modules==0.2.8
+pycparser==2.20
+pymongo==3.11.3
+pyparsing==2.4.7
+python-dateutil==2.8.1
+python-dotenv==0.15.0
+python-editor==1.0.4
+pytz==2021.1
+regex==2020.11.13
+requests==2.25.1
+rsa==4.7.2
+six==1.15.0
+SQLAlchemy==1.3.22
+toml==0.10.2
+typed-ast==1.4.2
+typing-extensions==3.7.4.3
+uritemplate==3.0.1
+urllib3==1.26.4
+Werkzeug==1.0.1
diff --git a/docker-compose.yml b/docker-compose.yml
index cc8f665..6713f35 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,44 +1,44 @@
-version: '3.7'
-
-services:
-  frontend:
-    build:
-      context: ./frontend
-      dockerfile: Dockerfile
-    volumes:
-      - ./frontend:/app
-      - /app/node_modules
-    ports:
-      - 3000:3000
-    environment:
-      - CHOKIDAR_USEPOLLING=true
-    env_file:
-      - ./.env
-  py-backend:
-    restart: always
-    build:
-      context: ./backend/python
-      dockerfile: Dockerfile
-    ports:
-      - 5000:5000
-    dns:
-      - 8.8.8.8
-    volumes:
-      - ./backend/python:/app
-      - file_uploads:/var/lib/file_uploads
-    depends_on:
-      - db
-    env_file:
-      - ./.env
-  db:
-    image: postgres:12-alpine
-    ports:
-      - 5432:5432
-    volumes:
-      - postgres_data:/var/lib/postgresql/data/
-    env_file:
-      - ./.env
-
-volumes:
-  postgres_data:
-  file_uploads:
+version: '3.7'
+
+services:
+  frontend:
+    build:
+      context: ./frontend
+      dockerfile: Dockerfile
+    volumes:
+      - ./frontend:/app
+      - /app/node_modules
+    ports:
+      - 3000:3000
+    environment:
+      - CHOKIDAR_USEPOLLING=true
+    env_file:
+      - ./.env
+  py-backend:
+    restart: always
+    build:
+      context: ./backend/python
+      dockerfile: Dockerfile
+    ports:
+      - 5000:5000
+    dns:
+      - 8.8.8.8
+    volumes:
+      - ./backend/python:/app
+      - file_uploads:/var/lib/file_uploads
+    depends_on:
+      - db
+    env_file:
+      - ./.env
+  db:
+    image: postgres:12-alpine
+    ports:
+      - 5432:5432
+    volumes:
+      - postgres_data:/var/lib/postgresql/data/
+    env_file:
+      - ./.env
+
+volumes:
+  postgres_data:
+  file_uploads:
diff --git a/frontend/src/components/auth/Login.tsx b/frontend/src/components/auth/Login.tsx
index b573ae8..7dcc9dc 100644
--- a/frontend/src/components/auth/Login.tsx
+++ b/frontend/src/components/auth/Login.tsx
@@ -1,56 +1,56 @@
-import React, { useContext, useState } from "react";
-import { Redirect } from "react-router-dom";
-import authAPIClient from "../../APIClients/AuthAPIClient";
-import AuthContext, { AuthenticatedUser } from "../../contexts/AuthContext";
-import ResetPassword from "./ResetPassword";
-
-const Login = () => {
-  const { authenticatedUser, setAuthenticatedUser } = useContext(AuthContext);
-  const [email, setEmail] = useState("");
-  const [password, setPassword] = useState("");
-
-  const onLogInClick = async () => {
-    const user: AuthenticatedUser = await authAPIClient.login(email, password);
-    setAuthenticatedUser(user);
-  };
-
-  if (authenticatedUser) {
-    return <Redirect to="/" />;
-  }
-
-  return (
-    <div style={{ textAlign: "center" }}>
-      <h1>Login</h1>
-      <form>
-        <div>
-          <input
-            type="email"
-            value={email}
-            onChange={(event) => setEmail(event.target.value)}
-            placeholder="username@domain.com"
-          />
-        </div>
-        <div>
-          <input
-            type="password"
-            value={password}
-            onChange={(event) => setPassword(event.target.value)}
-            placeholder="password"
-          />
-        </div>
-        <div>
-          <button
-            className="btn btn-primary"
-            type="button"
-            onClick={onLogInClick}
-          >
-            Log In
-          </button>
-          <ResetPassword email={email} />
-        </div>
-      </form>
-    </div>
-  );
-};
-
-export default Login;
+import React, { useContext, useState } from "react";
+import { Redirect } from "react-router-dom";
+import authAPIClient from "../../APIClients/AuthAPIClient";
+import AuthContext, { AuthenticatedUser } from "../../contexts/AuthContext";
+import ResetPassword from "./ResetPassword";
+
+const Login = () => {
+  const { authenticatedUser, setAuthenticatedUser } = useContext(AuthContext);
+  const [email, setEmail] = useState("");
+  const [password, setPassword] = useState("");
+
+  const onLogInClick = async () => {
+    const user: AuthenticatedUser = await authAPIClient.login(email, password);
+    setAuthenticatedUser(user);
+  };
+
+  if (authenticatedUser) {
+    return <Redirect to="/" />;
+  }
+
+  return (
+    <div style={{ textAlign: "center" }}>
+      <h1>Login</h1>
+      <form>
+        <div>
+          <input
+            type="email"
+            value={email}
+            onChange={(event) => setEmail(event.target.value)}
+            placeholder="username@domain.com"
+          />
+        </div>
+        <div>
+          <input
+            type="password"
+            value={password}
+            onChange={(event) => setPassword(event.target.value)}
+            placeholder="password"
+          />
+        </div>
+        <div>
+          <button
+            className="btn btn-primary"
+            type="button"
+            onClick={onLogInClick}
+          >
+            Log In
+          </button>
+          <ResetPassword email={email} />
+        </div>
+      </form>
+    </div>
+  );
+};
+
+export default Login;
diff --git a/frontend/src/components/auth/ResetPassword.tsx b/frontend/src/components/auth/ResetPassword.tsx
index 3d89e93..0579759 100644
--- a/frontend/src/components/auth/ResetPassword.tsx
+++ b/frontend/src/components/auth/ResetPassword.tsx
@@ -1,46 +1,46 @@
-import React, { useContext } from "react";
-import authAPIClient from "../../APIClients/AuthAPIClient";
-import AuthContext from "../../contexts/AuthContext";
-
-interface ResetPasswordProps {
-  email?: string;
-}
-
-const ResetPassword = ({ email }: ResetPasswordProps) => {
-  const { authenticatedUser } = useContext(AuthContext);
-
-  const isRealEmailAvailable = (emailString: string): boolean => {
-    const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
-    return re.test(String(emailString).toLowerCase());
-  };
-
-  const onResetPasswordClick = async () => {
-    if (authenticatedUser == null && !isRealEmailAvailable(email!)) {
-      alert("invalid email");
-      return;
-    }
-    const resetEmail = authenticatedUser?.email ?? email;
-    if (await authAPIClient.resetPassword(resetEmail)) {
-      alert(`Reset email sent to ${resetEmail}`);
-    } else {
-      alert(`Unsuccessful attempt to send reset email. 
-        Check that email is correct.`);
-    }
-  };
-
-  return (
-    <button
-      type="button"
-      className="btn btn-primary"
-      onClick={onResetPasswordClick}
-    >
-      Reset Password
-    </button>
-  );
-};
-
-ResetPassword.defaultProps = {
-  email: "",
-};
-
-export default ResetPassword;
+import React, { useContext } from "react";
+import authAPIClient from "../../APIClients/AuthAPIClient";
+import AuthContext from "../../contexts/AuthContext";
+
+interface ResetPasswordProps {
+  email?: string;
+}
+
+const ResetPassword = ({ email }: ResetPasswordProps) => {
+  const { authenticatedUser } = useContext(AuthContext);
+
+  const isRealEmailAvailable = (emailString: string): boolean => {
+    const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
+    return re.test(String(emailString).toLowerCase());
+  };
+
+  const onResetPasswordClick = async () => {
+    if (authenticatedUser == null && !isRealEmailAvailable(email!)) {
+      alert("invalid email");
+      return;
+    }
+    const resetEmail = authenticatedUser?.email ?? email;
+    if (await authAPIClient.resetPassword(resetEmail)) {
+      alert(`Reset email sent to ${resetEmail}`);
+    } else {
+      alert(`Unsuccessful attempt to send reset email. 
+        Check that email is correct.`);
+    }
+  };
+
+  return (
+    <button
+      type="button"
+      className="btn btn-primary"
+      onClick={onResetPasswordClick}
+    >
+      Reset Password
+    </button>
+  );
+};
+
+ResetPassword.defaultProps = {
+  email: "",
+};
+
+export default ResetPassword;
